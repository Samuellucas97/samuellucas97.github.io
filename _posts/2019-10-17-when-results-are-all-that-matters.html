---
layout: post
title: 'When Results Are All That Matters: Consequences'
date: '2019-10-17T18:07:00.003+02:00'
author: Andreas Zeller
tags: popular
modified_time: '2019-10-17T18:25:40.786+02:00'
blogger_id: tag:blogger.com,1999:blog-8747085902902510837.post-5155916221025431975
blogger_orig_url: https://andreas-zeller.blogspot.com/2019/10/when-results-are-all-that-matters.html
---

by Andreas Zeller and Sascha Just; with Kai Greshake<br /><br /> <h2>The Case</h2> In our previous post "<a href="https://andreas-zeller.blogspot.com/2019/10/when-results-are-all-that-matters-case.html" target="_blank">When Results Are All That Matters: The Case of the Angora</a>&nbsp;<a href="https://andreas-zeller.blogspot.com/2019/10/when-results-are-all-that-matters-case.html" target="_blank">Fuzzer</a>", we reported our findings when investigating the Angora fuzzer [1]. If you have not read that post yet, you should stop here and read our <a href="https://andreas-zeller.blogspot.com/2019/10/when-results-are-all-that-matters-case.html" target="_blank">write-up</a>&nbsp;first. There, we focus on our findings and problems that surprised us when experimenting with Angora. <br />In this article, we have collected some suggestions to advance the field of fuzzing and have a long-term impact on the reliability of software.<br /><br /> <h2>1. Science is about insights, not products.</h2> To ensure scientific progress, we need to know which technique works, how, and under which circumstances. We write papers to document such insights such that the next generation of researchers, as well as the non-scientific world, can build on them. &nbsp;The value of a paper comes from the impact of its insights.<br /><br /> <h2>2. Scientists and companies <i>can</i> create tools.</h2> It is fun to build a tool, and if it works well, the better. &nbsp;Typically, this will involve not one single magical technique, but a multitude of techniques working together. &nbsp;Tools will have to succeed on the market, though, and will be evaluated not based on their insights, but their effectiveness.<br /><br />Evaluating tools for their effectiveness can be part of a scientific approach. However, evaluation settings should<br /><ol><li>be <i>fair</i> and thus not be defined by tool authors; and</li><li>avoid <i>overspecialization</i> and thus involve tests not previously known to tool authors.</li></ol>In other words, the only way to obtain reliable performance comparisons is by independent assessment. &nbsp; Other communities do this through specific tool contests that operate on secret benchmarks created for this very purpose. &nbsp;And of course, tools need to be available for evaluation in the first place. It is nice to see the security community to adapt such techniques, such as artifact evaluation.<br /><br /> <h2>3. Combinations of techniques must be assessed individually.</h2> If results depend on a larger set of novel processing steps, the contribution of each must be – for instance, by replacing each processing step by a naive approach and assessing the impact of the change. &nbsp;All decisions affecting performance must be well motivated and documented.<br /><br />Without assessing the impact of each step individually, one can still have a great tool, but the insight on what makes it great will be very limited. &nbsp;As an analogy: We know that Usain Bolt is a record shattering sprinter; the scientific insight is to find out why.<br /><br /> <h2>4. Document your hypotheses, experiments, and results.</h2> Good scientific practice mandates that experiments and their results be carefully documented. &nbsp;This helps others (but also yourself!) in assessing and understanding the decisions in the course of your project. &nbsp;If you make some design decision, such as a parameter setting, after examining how your software runs on some example, it is important that the motivation for this design decision can be traced back to the experiment and its result.<br /><br />If this sounds like lot of work, that's because it is. &nbsp;We're talking about the scientific method, not some fiddling around with parameters until we reach the desired result on a benchmark. &nbsp;Fortunately, there are great means to help you with these tasks. &nbsp;Jupyter Notebooks [8], for instance, allow you to collect your hypotheses (in natural language), your experiment design, its results (in beautiful and interactive graphs, among others), and your next refinement step – allowing anyone (as well as yourself) to understand how a specific result came to be. &nbsp;Be sure to place your notebooks (and code) under version control from day one, and throw in some tests and assertions for quality assurance. &nbsp;Control your environment carefully to make results reproducible for anyone. <br /><br /> <h2>5. Having benchmarks to compare tools and approaches is helpful, but brings risks.</h2> Benchmarks are helpful means to assess the performance of tools. &nbsp;However, they bring two risks.<br /><ol><li>First, there is the risk of having researchers <i>focus on the benchmark</i> rather than insights. &nbsp;It is nice to have a well-performing tool, but its scientific value comes from the insights that make its performance.</li><li>Second, benchmarks bring the risk of researchers knowingly or unknowingly optimizing their tools for this very benchmark. We have seen this with compilers, databases, mobile phones, fault localization, machine learning, and now fuzzing. &nbsp;To mitigate the risk of overspecialization, tool performance should be compared on <i>programs they have not seen before.</i></li></ol>A benchmark like LAVA-M is representative for detecting buffer overflows during input processing but very little else. &nbsp;As the LAVA creators state themselves, "LAVA currently injects only buffer overflows into programs" and "A significant chunk of future work for LAVA involves making the generated corpora look more like the bugs that are found in real programs." [3].<br /><br />It has been shown that optimizing against the artificial LAVA bugs, such as 4-byte string triggers, can have very naive approaches yield impressive results [2]. &nbsp;The conceptual match between the features injected by LAVA and those features exploited by fuzzers such as Angora is striking.<br /><br />The question of what makes a good benchmark for fuzzers and test generation is still open. &nbsp;One possible alternative to LAVA-M is Google's fuzzing test suite which contains a diverse set of programs with real bugs [5]. &nbsp;Michael Hicks has compiled excellent guidelines on how to evaluate fuzzers [4, 6]. <br /><br /> <h2>6. Researchers must resist the temptation of optimizing their tools towards a specific benchmark.</h2> While developing an approach, it is only natural to try it out on some examples to assess its performance, such that results may guide further refinement. The risk of such guidance, however, is that development may result in overspecialization – i.e., an approach that works well on a benchmark, but not on other programs. &nbsp;As a result, one will get a paper without impact and a tool that nobody uses.<br /><br />Every choice during implementation has to be questioned "Will this solve a general problem that goes way beyond my example?", and one should take that choice only with a positive, well-motivated answer, possibly involving other experts who would be asked in the abstract. &nbsp;We recommend that during implementation, only a very small set of examples should be used for guidance; the evaluation should later be run on the full benchmark.<br /><br />Good scientific practice mandates to create a research and evaluation plan with a clear hypothesis well before the evaluation, and possibly even before the implementation. &nbsp;This helps to avoid being too biased towards one's own approach. Note that the point of the evaluation is not to show that an approach works, but to precisely identify the circumstances under which it works and the circumstances under which it does not work.<br /><br />Papers should investigate those situations and clearly report them. Again, papers are about insights, not competition.<br /><br /> <h2>7. It is nice to have tools discovering vulnerabilities...</h2> ...especially as these vulnerabilities have a value on their own. However, vulnerabilities do not follow statistical distribution rules (hint: otherwise it would be easier to find them). &nbsp;Having a tool find a number of vulnerabilities in a program, therefore, is not necessarily a good predictor to find bugs in another program.<br /><br />In any case, the process through which vulnerabilities were found must be carefully documented and made fully reproducible; for random-driven approaches such as fuzzers, one thus needs to log and report random seeds. &nbsp;Obviously, one must be clear not to optimize tools towards given vulnerabilities.<br /><br />For fuzzing tools, the technical challenge is to find inputs that cover a wide range of behavior across the program and not only during input processing and error handling. &nbsp;Let us remind you that during testing, executing a location is a necessary condition for finding a bug in that very location. &nbsp;Since we are still far from reaching satisfying results in covering functionality, improvements in code coverage are important achievements regardless of bugs being found.<br /><br /> <h2>8. What does this mean for reviewers and authors?</h2> Papers must clearly show how the insights of the paper contribute to the result, both in terms of motivation as well as in evaluation.<br /><br />In many cases, it will be hard to describe all the details of all the necessary steps in the paper. Therefore, it will be necessary to supply an artifact that allows for not only reproduction but also applying it on subjects not seen before; again, all design decisions in the code must be motivated and documented. This is tedious; this is rigorous; this is how science works.<br /><br />Reviewers should be aware that an approach is not simply "better" because it performs well on a benchmark or because it found new bugs. &nbsp;Approaches have a long-term impact not only through performance, but also through innovation, generality, and simplicity. Researchers are selected as reviewers because the community trusts them to assess such qualities. Tool performance that is achieved through whatever means has little scientific value.<br /><br />Having said that, conference organizers should create forums for tool builders and tool users to discuss lessons learned. &nbsp;Such exchanges can be extremely fruitful for scientific progress, even if they may not be subject to rigorous scientific assessment. &nbsp;Tool contests with clear and fair rules would allow assessing the benefits and fallbacks of current approaches, and again to foster and guide discussions on where the field should be going. &nbsp;A contest like Rode0day [7] could serve as a starting point.<br /><br /> <h2>Conclusion</h2> Having tools is good, and having tools that solve problems is even better. &nbsp;As scientists, however, we also must understand <i>why</i>&nbsp;<i>what</i>&nbsp;works and what does not. &nbsp;As tools and vulnerabilities come and go, it is these insights that have the longest impact. &nbsp;Our papers, our code and our processes, therefore, must all be shaped to produce, enable, assess, and welcome such insights. &nbsp;This is the long-term path of how we as scientists can help to make software more reliable and more secure.<br /><br /><i><b>Acknowledgments.</b>&nbsp;&nbsp;Marcel Böhme, Cas Cremers, Thorsten Holz, Mathias Payer, and Ben Stock provided helpful feedback on earlier revisions of this post. &nbsp;Thanks a lot!</i><br /><br /> <h2>References</h2> [1] P. Chen and H. Chen, "<a href="https://ieeexplore.ieee.org/document/8418633" target="_blank">Angora: Efficient Fuzzing by Principled Search</a>." 2018 IEEE Symposium on Security and Privacy (IEEE S&amp;P), San Francisco, CA, 2018, pp. 711-725.<br />[2] <a href="http://moyix.blogspot.com/2018/03/of-bugs-and-baselines.html" target="_blank">Of bugs and baselines</a><br />[3] B. Dolan-Gavitt et al., "<a href="https://ieeexplore.ieee.org/document/7546498" target="_blank">LAVA: Large-Scale Automated Vulnerability Addition</a>," 2016 IEEE Symposium on Security and Privacy (S&amp;P), San Jose, CA, 2016, pp. 110-121.<br />[4] George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei, and Michael Hicks. 2018. <a href="https://arxiv.org/pdf/1808.09700.pdf" target="_blank">Evaluating Fuzz Testing</a>. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS '18). ACM, New York, NY, USA, 2123-2138.<br />[5] <a href="https://github.com/google/fuzzer-test-suite" target="_blank">Google's fuzzing test suite</a><br />[6] Michael Hicks, <a href="http://www.pl-enthusiast.net/2018/08/23/evaluating-empirical-evaluations-for-fuzz-testing/" target="_blank">Evaluating Empirical Evaluations (for Fuzz Testing</a><br />[7] <a href="https://rode0day.mit.edu/" target="_blank">Rode0day</a><br />[8] <a href="https://jupyter.org/" target="_blank">Project Jupyter</a><br />