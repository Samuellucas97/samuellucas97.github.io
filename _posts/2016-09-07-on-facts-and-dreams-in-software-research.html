---
layout: post
title: On Facts and Dreams in Software Research
date: '2016-09-07T06:43:00.000+02:00'
author: Andreas Zeller
tags: 
modified_time: '2016-09-07T06:46:58.332+02:00'
blogger_id: tag:blogger.com,1999:blog-8747085902902510837.post-2695849986551826238
blogger_orig_url: https://andreas-zeller.blogspot.com/2016/09/on-facts-and-dreams-in-software-research.html
---

<br /><div class="p1"><i><b>Where is the economic argument in program verification research, and where are the salvation messages in software engineering research?</b></i></div><div class="p1"><i><b><br /></b></i></div><div class="p1">I just had the pleasure of attending <a href="http://www.comp.nus.edu.sg/~david/" target="_blank">David Rosenblum’s</a> keynote at <a href="http://www.ase2016.org/" target="_blank">ASE 2016</a>, in which he praised the power of probabilistic thinking (using stochastic reasoning to estimate risks and support decisions) versus an absolutistic view in which there is only 100% truth or 100% failure.&nbsp; His takeaway message was that software engineers should embrace probabilistic methods and permeate them throughout the development process.</div><div class="p2"><br /></div><div class="p1">As a software engineer, probabilistic thinking is a central part of my day-to-day job –&nbsp;in development as in research.&nbsp; Whatever I build and design, I think about how useful it might be, which benefits it may bring, and what the associated risks are.&nbsp; In Software Engineering research, <a href="http://andreas-zeller.blogspot.sg/2012/10/what-makes-good-research.html" target="_blank">the dominating metric is usefulness</a>, which eventually translates into an <i>economic</i> argument: What does it cost? What are the benefits? What are the risks?&nbsp; These are day-to-day questions in software development, and my research is expected to provide facts to help answer them.</div><div class="p2"><br /></div><div class="p1">In other fields of computer science, such as software verification, the economic perspective is much less argued about.&nbsp; Instead, the message touted is an absolutistic message of <i>salvation:</i> If you apply this technique, you will get a 100% guarantee that your software satisfies certain requirements –&nbsp;that the computation will be correct, that it will not crash, or that it will terminate within specific time bounds.&nbsp; For developers and society, this message feels like the second coming of Christ: The day will come and all your problems will be gone. &nbsp;</div><div class="p2"><br /></div><div class="p1">Up to now, there are great examples of how software verification works, and there are impressive examples of it being successfully used in practice; and just to be clear: By no means would I want to reduce these research efforts.&nbsp;&nbsp;But the systems formal verification is applied to are still small and constrained; and getting it to scale and widen will require enormous human effort reshaping existing systems – before salvation comes repent.&nbsp; Do we actually know how costly formally verified software is?&nbsp; Do we know how to teach its techniques to developers who do not hold a PhD?&nbsp; Can we estimate the risks it brings to rely on freshly written specifications, rather than on mature systems?&nbsp; Might "good enough" software be good enough? &nbsp;When talking to researchers in software verification, such economic arguments are frequently missing in the debate. But as a society, we need to understand where money is best spent, and answers to such questions could very well guide the field of software research.</div><div class="p2"><br /></div><div class="p1"></div><div class="p1">Conversely, just as formal verification may benefit from introducing an economic perspective, Software Engineering may profit from adapting a stronger <i>salvation</i> perspective.&nbsp; What is it that Software Engineering research could produce that would be seen as a salvation in software development –&nbsp;a significant reduction of costs or risks?&nbsp; Recent topics that come to my mind are <a href="http://automated-program-repair.org/" target="_blank">automatic software debugging and repair</a>, steering development processes based on <a href="http://www.msrconf.org/" target="_blank">mining software histories</a>, or massive <a href="http://www.evosuite.org/" target="_blank">automated test generation</a>.&nbsp; Can we translate our capabilities into <i>grand challenges</i> that will provide salvation in the future, possibly even including guarantees?&nbsp; Yes, I know there are “<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank">no silver bullets</a>” in software development.&nbsp; But any great research community should pursue great dreams as well as provide facts – and in this, all of us computer science researchers are in the same boat.</div>